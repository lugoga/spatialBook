{"title":"Spatial interpolation of point data","markdown":{"headingText":"Spatial interpolation of point data","containsRefs":false,"markdown":"\n## Aims\n\nOur aims in this chapter are:\n\n-   Calculate an empirical variogram\n\n-   Fit a variogram model\n\n-   Interpolate using three methods:\n\n    -   Inverse Distance Weighted (IDW) interpolation\n\n    -   Ordinary Kriging (OK)\n\n    -   Universal Kriging (UK)\n\n-   Evaluate interpolation accuracy using Leave-One-Out Cross Validation\n\nWe will use the following R packages:\n\n-   `sf`\n\n-   `stars`\n\n-   `gstat`\n\n-   `automap`\n\n## What is spatial interpolation?\n\n### Interpolation models\n\n**Spatial interpolation** is the prediction of a given phenomenon in unmeasured locations (Figures [12.1](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:interpolation1)--[12.2](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:interpolation2)). For that, we need a spatial interpolation **model**---a set of procedures to calculate **predicted** values of the variable of interest, given **calibration** data.\n\nFigure 12.1: Spatial interpolation (Input elevation point data, Interpolated elevation surface) (<http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/understanding-interpolation-analysis.htm>)\n\nFigure 12.2: Spatial interpolation (Point locations of ozone monitoring stations, Interpolated prediction surface) (<http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/understanding-interpolation-analysis.htm>)\n\nCalibrarion data usually include:\n\n-   **Field measurements**---available for a limited number of locations, for example: rainfall data from meteorological stations\n\n-   **Covariates**---available for each and every location within the area of interest, for example: elevation from a DEM\n\nSpatial interpolation models can be divided into two general categories:\n\n-   **Deterministic models**---Models using arbitrary parameter values, for example: IDW\n\n-   **Statistical models**---Models using parameters chosen objectively based on the data, for example: Kriging\n\nKeep in mind that data *structure* does not imply *meaning*. It is technically possible to interpolate any numeric variable measured in a set of points, however it does not always make sense to do so. For example, it does not make sense to spatially interpolate point data when they refer to a localized phenomenon, such as amount of emissions per power plant (Figure [12.3](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:point-vs-continuous1)).\n\nFigure 12.3: CO2��2 emissions from power plants: a localized phenomenon (<https://edzer.github.io/UseR2016/>)\n\nConveresly, it does not make sense to sum up point measurements of a continuous phenomenon (Figure [12.4](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:point-vs-continuous2)).\n\nFigure 12.4: PM10��10 measurements: a continuous phenomenon (<https://edzer.github.io/UseR2016/>)\n\n### 12.1.2 The weighted average principle\n\nMany of the commonly used interpolation methods, including the ones we learn about in this Chapter (Nearest Neighbor, IDW, Kriging), are based on the same principle, where a predicted value is a **weighted average** of neighboring points. Weight are usually inveresely related to distance, i.e., as distance increases the weight (importance) of the point decreases. The predicted value for a particular point is calculated as a weighted average of measured values in other points (Equation [(12.1)](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:weighted-average)):\n\n[^Z(s0)=∑ni=1w(si)Z(si)∑ni=1w(si)(12.1)(12.1)�^(�0)=∑�=1��(��)�(��)∑�=1��(��)]{.underline}\n\nwhere:\n\n-   ^Z(s0)�\\^(�0) is the predicted value at location s0�0\n\n-   w(si)�(��) is the weight of measured point i�\n\n-   Z(si)�(��) is the value of measured point i�\n\nThe weight w(si)�(��) of each measured point is a function of distance (Figure [12.5](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:distance-observed-predicted)) from the predicted point.\n\nFigure 12.5: Distances between predicted point and all measured points (<http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-kriging-works.htm>)\n\nIn IDW, the weight is the inverse of distance to the power of p� (Equation [(12.2)](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:idw)):\n\n[w(si)=1d(s0,si)p(12.2)(12.2)�(��)=1�(�0,��)�]{.underline}\n\nwhere:\n\n-   w(si)�(��) is the weight of measured point i�\n\n-   d(s0,si)�(�0,��) is the distance between predicted point s0�0 and measured point si��\n\nThe default value for p� is usually p=2�=2 (Equation [(12.3)](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:idw2)):\n\n[w(si)=1d(s0,si)2(12.3)(12.3)�(��)=1�(�0,��)2]{.underline}\n\nThe p� parameter basically determines how steeply does weight increase with proximity. As a result, p� determines whether weights are more or less equally distributed among neighbors (low p�) or whether one point (the nearest) has overwhelmingly high weight and thus the predicted value will be strongly influenced by that point (high p�). In other words, when p� approaches zero, the predicted result will approach a uniform surface which is just an average of all measured points. When p� approaches infinity, the predicted result will approach nearest **neighbor interpolation**, which is the simplest *spatial* interpolation method there is: every predicted point gets the value of the nearest measured point (Figures [12.6](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:idw-p)--[12.7](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:nearest-neighbor)).\n\nFigure 12.6: Spatial interpolation of annual rainfall using IDW with p=0.25�=0.25, p=2�=2 and p=16�=16\n\nFigure 12.7: Nearest Neighbor interpolation (left) and Voronoi polygons (right)\n\nIn Kriging, the weight is a particular function of distance known as the **variogram model** (Figure [12.8](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram-models)). The variogram model is fitted to characterize the autocorrelation structure in the measured data, based on the **empirical variogram**.\n\nFigure 12.8: Variogram models: spherical (left) and exponential (right) (<http://desktop.arcgis.com/en/arcmap/10.3/tools/spatial-analyst-toolbox/how-kriging-works.htm>)\n\nThere are two frequently used kriging methods: Ordinary Kriging (OK) and Universal Kriging (UK). Adding up the Inverse Distance Weighted (IDW) interpolation, we now mentioned three interpolation methods. We are going to cover those three methods (Figure [12.9](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:idw-ok-uk)), mostly from the practical point of view, in the next three sections (Sections [12.2](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#inverse-distance-weighted-interpolation)--[12.4](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#universal-kriging)).\n\nFigure 12.9: Spatial interpolation of annual rainfall using IDW, OK and UK\n\nFor the examples, we will load the `rainfall.csv` file (Section [4.4.3](https://geobgu.xyz/r-2021/tables-conditionals-and-loops.html#example-the-rainfall-csv-structure)), calculate the `annual` column (Section [4.5](https://geobgu.xyz/r-2021/tables-conditionals-and-loops.html#the-apply-function)) and convert it to a point layer (Section [7.4](https://geobgu.xyz/r-2021/vector-layers.html#creating-point-layer-from-table)):\n\n```         \nlibrary(sf) rainfall = read.csv(\"rainfall.csv\") rainfall = st_as_sf(rainfall, coords = c(\"x_utm\", \"y_utm\"), crs = 32636) m = c(\"sep\", \"oct\", \"nov\", \"dec\", \"jan\", \"feb\", \"mar\", \"apr\", \"may\") rainfall$annual = apply(st_drop_geometry(rainfall[, m]), 1, sum)\n```\n\nWe will also use a 1×11×1 km2��2 DEM raster of the area of interest (Sections [9.1](https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#mosaicking-rasters), [9.3](https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-reprojection) and [10.1](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#masking-and-cropping-rasters)):\n\n```         \nlibrary(stars) dem1 = read_stars(\"srtm_43_06.tif\") dem2 = read_stars(\"srtm_44_06.tif\") dem = st_mosaic(dem1, dem2) borders = st_read(\"israel_borders.shp\") grid = st_as_sfc(st_bbox(borders)) grid = st_as_stars(grid, dx = 1000, dy = 1000) dem = st_warp(src = dem, grid, method = \"average\", use_gdal = TRUE) dem = dem[borders] names(dem) = \"elev_1km\"\n```\n\nFinally, we subset the `dem` to include only the area to the north of 31 degrees latitude, where meteorological station density is relatively high:\n\n```         \ny = st_as_sf(dem, as_points = TRUE) y$lat = st_coordinates(st_transform(y, 4326))[,2] y = st_rasterize(y[, \"lat\"], dem) y[y < 31] = NA y[!is.na(y)] = 1 y = st_as_sf(y, merge = TRUE) dem = dem[y]\n```\n\nNext, we *extract* the elevation values (Section [10.7.2](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-points-single-band)):\n\n```         \nrainfall = st_join(rainfall, st_as_sf(dem))\n```\n\nand subset those stations that coincide with the raster:\n\n```         \nrainfall = rainfall[!is.na(rainfall$elev_1km), ]\n```\n\nFigure [12.10](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:elevation-rainfall) shows the `dem` elevation raster and the `rainfall` point layer:\n\n```         \nplot(dem, breaks = \"equal\", col = terrain.colors(11), reset = FALSE) plot(st_geometry(rainfall), add = TRUE)\n```\n\nFigure 12.10: Rainfall data points and elevation raster\n\n## Inverse Distance Weighted interpolation\n\n### The `gstat` object\n\nTo interpolate, we first need to create an object of class `gstat`, using a function of the same name: `gstat`. A `gstat` object contains all necessary information to conduct spatial interpolation, namely:\n\n-   The **model** definition\n\n-   The calibration **data**\n\nBased on its arguments, the `gstat` function \\\"understands\\\" what type of interpolation model we want to use:\n\n-   No variogram model → **IDW**\n\n-   Variogram model, no covariates → **Ordinary Kriging**\n\n-   Variogram model, with covariates → **Universal Kriging**\n\nThe complete decision tree of `gstat`, including several additional methods which we are not going to use, is shown in Figure [12.11](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:gstat-decision-tree).\n\nFigure 12.11: `gstat` predict methods (Applied Spatial Data Analysis with R, 2013)\n\nWe are going to use three parameters of the `gstat` function:\n\n-   `formula`---The prediction **\\\"formula\\\"** specifying the dependent and the independent variables (covariates)\n\n-   `data`---The calibration **data**\n\n-   `model`---The **variogram** model\n\nKeep in mind that we need to specify parameter names, because these three parameters are not the first three in the `gstat` function definition.\n\nFor example, to interpolate using the **IDW** method we create the following `gstat` object, specifying just the `formula` (Section [12.2.2](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#working-with-formula-objects) below) and `data`:\n\n```         \nlibrary(gstat) g = gstat(formula = annual ~ 1, data = rainfall)\n```\n\n### Working with `formula` objects\n\nIm R, `formula` objects are used to specify *relation* between objects, in particular---the role of different data columns in statistical models. A `formula` object is created using the `~` operator, which separates names of **dependent** variables (to the left of the `~` symbol) and **independent** variables (to the right of the `~` symbol). Writing `1` to the right of the `~` symbol, as in `~ 1`, means that there are no independent variables^[39](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fn39)^.\n\nFor example, in the following expression we create a `formula` object named `f`:\n\n```         \nf = annual ~ 1 f ## annual ~ 1\n```\n\nChecking the class shows that `f` is indeed a `formula` object:\n\n```         \nclass(f) ## [1] \"formula\"\n```\n\nWe can also convert `character` values to `formula` using the `as.formula` function. For example:\n\n```         \nf = as.formula(\"annual ~ 1\") class(f) ## [1] \"formula\"\n```\n\nThe `as.formula` function is particularly useful when we want to construct different formulas as part of a `for` loop (Section [12.3.3](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#monthly-rainfall-example)).\n\n### Making predictions\n\nNow that our model is defined, we can use the `predict` function to actually interpolate, i.e., to calculate predicted values. The `predict` function accepts:\n\n-   A **raster**---`stars` object, such as `dem`\n\n-   A **model**---`gstat` object, such as `g`\n\nThe raster serves for two purposes:\n\n-   Specifying the **locations** where we want to make predictions (in all methods)\n\n-   Specifying **covariate** values (in Universal Kriging only)\n\nFor example, the following expression interpolates `annual` values according to the model defined in `g` and the raster template defined in `dem`:\n\n```         \nz = predict(g, dem) ## [inverse distance weighted interpolation]\n```\n\nThe resulting `stars` object has two attributes:\n\n-   `var1.pred`---the predicted values\n\n-   `var1.var`---the variance (for Kriging only)\n\nFor example:\n\n```         \nz ## stars object with 2 dimensions and 2 attributes ## attribute(s): ##    var1.pred        var1.var      ##  Min.   : 42.85   Min.   : NA     ##  1st Qu.:356.01   1st Qu.: NA     ##  Median :495.20   Median : NA     ##  Mean   :466.49   Mean   :NaN     ##  3rd Qu.:552.16   3rd Qu.: NA     ##  Max.   :946.31   Max.   : NA     ##  NA's   :20108    NA's   :39933   ## dimension(s): ##   from  to  offset delta                       refsys point values x/y ## x    1 153  616965  1000 +proj=utm +zone=36 +datum...    NA   NULL [x] ## y    1 261 3691819 -1000 +proj=utm +zone=36 +datum...    NA   NULL [y]\n```\n\nWe can subset just the first attribute and rename it to `\"annual\"`:\n\n```         \nz = z[\"var1.pred\",,] names(z) = \"annual\"\n```\n\nThe interpolated annual rainfall raster, using IDW, is shown in Figure [12.12](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-idw):\n\n```         \nb = seq(0, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, \"Spectral\"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)\n```\n\nFigure 12.12: Predicted annual rainfall using Inverse Distance Weighted (IDW) interpolation\n\n## Ordinary Kriging\n\n### Annual rainfall example\n\nKriging methods require a **variogram model**. The variogram model is an objective way to quantify the autocorrelation pattern in the data, and assign weights accordingly when making predictions (Section [12.1.2](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#the-weighted-average-principle)).\n\nAs a first step, we can calculate and examine the **empirical variogram** using the `variogram` function. The function requires two arguments:\n\n-   `formula`---Specifies the **dependent variable** and the **covariates**, just like in `gstat`\n\n-   `data`---The **point** layer with the dependent variable and covariates as point attributes\n\nFor example, the following expression calculates the empirical variogram of `annual`, with no covariates:\n\n```         \nv_emp_ok = variogram(annual ~ 1, rainfall)\n```\n\nUsing `plot` to examine it we can examine the variogram (Figure [12.13](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram)):\n\n```         \nplot(v_emp_ok)\n```\n\nFigure 12.13: Empirical variogram\n\nThere are several ways to fit a **variogram model** to an empirical variogram. We will use the simplest one---*automatic* fitting using function `autofitVariogram` from package `automap`:\n\n```         \nlibrary(automap) v_mod_ok = autofitVariogram(annual ~ 1, as(rainfall, \"Spatial\"))\n```\n\nThe function chooses the best fitting type of model, and also fine tunes its parameters. (Use `show.vgms()` to display variogram model types.) Note that the `autofitVariogram` function does not work on `sf` objects, which is why we convert the object to a `SpatialPointsDataFrame` (package `sp`).\n\nThe fitted model can be plotted with `plot` (Figure [12.14](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram-model)):\n\n```         \nplot(v_mod_ok)\n```\n\nFigure 12.14: Variogram model\n\nThe resulting object is actually a `list` with several components, including the empirical variogram and the fitted variogram model. The `$var_model` component of the resulting object contains the actual model:\n\n```         \nv_mod_ok$var_model ##   model      psill    range kappa ## 1   Nug   451.9177     0.00     0 ## 2   Ste 23223.8370 34604.87     2\n```\n\nThe variogram model can then be passed to the `gstat` function, and we can carry on with the Ordinary Kriging interpolation:\n\n```         \ng = gstat(formula = annual ~ 1, model = v_mod_ok$var_model, data = rainfall) z = predict(g, dem) ## [using ordinary kriging]\n```\n\nAgain, we will subset the predicted values attribute and rename it:\n\n```         \nz = z[\"var1.pred\",,] names(z) = \"annual\"\n```\n\nThe Ordinary Kriging predictions are shown in Figure [12.15](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-ok):\n\n```         \nb = seq(0, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, \"Spectral\"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)\n```\n\nFigure 12.15: Predicted annual rainfall using Ordinary Kriging\n\n### Elevation example\n\nAnother example: suppose that we did not have a DEM for Israel, but only the elevation measurements at the meteorological stations. How can we produce an elevation raster using Ordinary Kriging?\n\nFirst, we prepare the `gstat` object:\n\n```         \nv = autofitVariogram(altitude ~ 1, as(rainfall, \"Spatial\")) g = gstat(formula = altitude ~ 1, model = v$var_model, data = rainfall)\n```\n\nThen, we interpolate:\n\n```         \nz = predict(g, dem) ## [using ordinary kriging] z = z[\"var1.pred\",,] names(z) = \"elevation\"\n```\n\nThe predicted elevation raster is shown in Figure [12.16](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:elevation-ok):\n\n```         \nb = seq(-500, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, \"Spectral\"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)\n```\n\nFigure 12.16: Ordinary Kriging prediction of elevation\n\n### Monthly rainfall example\n\nIn the next example we use kriging inside a `for` loop, to make a series of predictions for different variables. Specifically, we will use Ordinary Kriging to predict *monthly rainfall*, i.e., `sep` through `may` columns in the `rainfall` layer.\n\nIn each `for` loop \\\"round,\\\" the formula is going to be re-defined according to the current month `i`. For example:\n\n```         \ni = \"may\" as.formula(paste0(i, \" ~ 1\")) ## may ~ 1\n```\n\nFirst, we set up a vector with the column names of the variables we wish to interpolate, and a `list` where we \\\"collect\\\" the results:\n\n```         \nm = c(\"sep\", \"oct\", \"nov\", \"dec\", \"jan\", \"feb\", \"mar\", \"apr\", \"may\") result = list()\n```\n\nSecond, we specify the `for` loop, as follows:\n\n```         \nfor(i in m) {   f = as.formula(paste0(i, \" ~ 1\"))   v = autofitVariogram(f, as(rainfall, \"Spatial\"))   g = gstat(formula = f, model = v$var_model, data = rainfall)   z = predict(g, dem)   z = z[\"var1.pred\",,]   result[[i]] = z } ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging] ## [using ordinary kriging]\n```\n\nFinally, we combine the `list` of results per month into a single multi-band raster, using `do.call` and `c` (Section [11.3.2](https://geobgu.xyz/r-2021/processing-spatio-temporal-data.html#aggregating-time-periods)):\n\n```         \nresult$along = 3 result = do.call(c, result)\n```\n\nThe interpolated montly rainfall amounts are shown in Figure [12.17](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:kriging-monthly-rainfall):\n\n```         \nplot(result, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), key.pos = 4)\n```\n\nFigure 12.17: Monthly rainfall predictions using Ordinary Kriging\n\n## Universal Kriging\n\n**Universal Kriging** interpolation uses a model with one or more independent variables, i.e., covariates. The covariates need to be known for both:\n\n-   The **point layer**, as an attribute such as `elev_1km` in `rainfall`\n\n-   The **predicted locations**, as raster values such as `dem` values\n\nThe `formula` now specifies the name(s) of the covariate(s) to the right of the `~` symbol, separated by `+` if there are more than one. Also, we are using a subset of `rainfall` where `elev_1km` values were present:\n\n```         \nv_emp_uk = variogram(annual ~ elev_1km, rainfall) v_mod_uk = autofitVariogram(annual ~ elev_1km, as(rainfall, \"Spatial\"))\n```\n\nComparing the Ordinary Kriging and Universal Kriging variogram models (Figure [12.18](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:variogram-models-ok-uk)):\n\n```         \nplot(v_emp_ok, model = v_mod_ok$var_model, ylim = c(0, 25000), main = \"OK\") plot(v_emp_uk, model = v_mod_uk$var_model, ylim = c(0, 25000), main = \"UK\")\n```\n\nFigure 12.18: OK and UK variogram models\n\nNext we create a `gstat` object, where the `formula` contains the covariate and the corresponding variogram model:\n\n```         \ng = gstat(formula = annual ~ elev_1km, model = v_mod_uk$var_model, data = rainfall)\n```\n\nRemember that all of the variables that appear in the `formula` need to be present in the `data`. In this case we have two variables: a dependent variable (`annual`) and an independent variable (`elev_1km`).\n\nNow we can make predictions:\n\n```         \nz = predict(g, dem) ## [using universal kriging]\n```\n\nand then subset and rename:\n\n```         \nz = z[\"var1.pred\",,] names(z) = \"annual\"\n```\n\nUniversal Kriging predictions are shown in Figure [12.19](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-uk):\n\n```         \nb = seq(0, 1200, 100) plot(z, breaks = b, col = hcl.colors(length(b)-1, \"Spectral\"), reset = FALSE) plot(st_geometry(rainfall), pch = 3, add = TRUE) contour(z, breaks = b, add = TRUE)\n```\n\nFigure 12.19: Predicted annual rainfall using Universal Kriging\n\n## Cross-validation\n\nIn Sections [12.2](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#inverse-distance-weighted-interpolation)--[12.4](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#universal-kriging), we have calculated annual rainfall surfaces using three different methods: IDW, Ordinary Kriging and Universal Kriging. Although it is useful to examine and compare the results graphically (Figures [12.12](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-idw), [12.15](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-ok), and [12.19](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:predicted-uk)), we also need an objective way to evaluate interolation *accuracy*. That way, we can objectively choose the most accurate method among the various interpolation methods there are.\n\nPlainly speaking, to evaluate prediction accuracy we need to compare the predicted values with measured data in the same location. Since measured data are often sparse and expensive to produce, it makes little sense to collect more data merely for the sake of accuracy assessment. Instead, the available data are usually *split* to two parst, called training and test data. The training data are used to fit the model, while the test data are used to calculate prediction accuracy. The procedure is called **cross validation**. A specific, commonly used, type of cross validation is **Leave-One-Out Cross Validation** where all observations consecutively take the role of test data while the remaning observations take the role of training data. The separation of training and test data is important because evaluating a model based on the same data used to fit it gives the model an \\\"unfair\\\" advantage and therefore overestimates accuracy.\n\nIn Leave-One-Out Cross Validation we:\n\n-   **Take out** one point out of the calibration data\n\n-   Make a **prediction** for that point\n\n-   **Repeat** for all points\n\nIn the end, what we get is a table with an *observed* value and a *predicted* value for all points.\n\nWe can run Leave-One-Out Cross Validation using the `gstat.cv` function, which accepts a `gstat` object:\n\n```         \ncv = gstat.cv(g)\n```\n\nThe `gstat.cv` function returns an object of class `SpatialPointsDataFrame` (package `sp`), which we can convert to an `sf` object with `st_as_sf`:\n\n```         \ncv = st_as_sf(cv) cv ## Simple feature collection with 160 features and 6 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 629301.4 ymin: 3435503 xmax: 761589.2 ymax: 3681163 ## CRS:           NA ## First 10 features: ##    var1.pred var1.var observed    residual       zscore fold ## 1   632.4635 951.6388    582.8 -49.6635206 -1.609909413    1 ## 2   614.6876 915.2690    608.5  -6.1876076 -0.204525930    2 ## 3   598.0584 907.7003    614.7  16.6415723  0.552361147    3 ## 4   609.5275 774.8052    562.7 -46.8274602 -1.682303431    4 ## 5   701.0174 913.6664    682.8 -18.2174496 -0.602689676    5 ## 6   610.4985 740.2553    705.5  95.0014929  3.491722024    6 ## 7   645.4771 824.3927    610.4 -35.0771011 -1.221677615    7 ## 8   581.9809 976.5117    583.3   1.3190893  0.042211954    8 ## 9   654.7017 705.9952    709.8  55.0983188  2.073659677    9 ## 10  654.6546 706.8918    654.8   0.1454226  0.005469598   10 ##                    geometry ## 1  POINT (697119.1 3656748) ## 2  POINT (696509.3 3652434) ## 3  POINT (696541.7 3641332) ## 4  POINT (697875.3 3630156) ## 5  POINT (689553.7 3626282) ## 6  POINT (694694.5 3624388) ## 7  POINT (686489.5 3619716) ## 8  POINT (683148.4 3616846) ## 9  POINT (696489.3 3610221) ## 10 POINT (693025.1 3608449)\n```\n\nThe result of `gstat.cv` has the following attributes:\n\n-   `var1.pred`---Predicted value\n\n-   `var1.var`---Variance (only for Kriging)\n\n-   `observed`---Observed value\n\n-   `residual`---Observed-Predicted\n\n-   `zscore`---Z-score (only for Kriging)\n\n-   `fold`---Cross-validation ID\n\nA **bubble plot** is convenient to examine the residuals, since it shows positive and negative values in different color (Figure [12.20](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#fig:bubble-plot)):\n\n```         \nbubble(as(cv[, \"residual\"], \"Spatial\"))\n```\n\nFigure 12.20: Cross-validation residuals\n\nUsing the \\\"predicted\\\" and \\\"observed\\\" columns we can calculate prediction accuracy indices, such as the **Root Mean Square Error (RMSE)** (Equation [(12.4)](https://geobgu.xyz/r-2021/spatial-interpolation-of-point-data.html#eq:rmse)):\n\n[RMSE=√∑ni=1(predi−obsi)2n(12.4)(12.4)����=∑�=1�(�����−����)2�]{.underline}\n\nwhere predi����� and obsi���� are *predicted* and *observed* values for point i�, respectively.\n\nFor example:\n\n```         \nsqrt(sum((cv$var1.pred - cv$observed)^2) / nrow(cv)) ## [1] 36.21741\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":"","engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":true,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["style.css"],"highlight-style":"ayu-mirage","output-file":"ch12.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.319","bibliography":["references.bib"],"linkcolor":"blue","citecolor":"red","crossref":{"fig-title":"**FIGURE**","fig-labels":"arabic","tbl-title":"**TABLE**","tbl-labels":"arabic","title-delim":"**.**"},"theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":"","engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","css":["style.css"],"highlight-style":"ayu-mirage","output-file":"ch12.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"linkcolor":"blue","citecolor":"red","crossref":{"fig-title":"**FIGURE**","fig-labels":"arabic","tbl-title":"**TABLE**","tbl-labels":"arabic","title-delim":"**.**"},"documentclass":"scrbook"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}