{"title":"Combining rasters and vector layers","markdown":{"headingText":"Combining rasters and vector layers","containsRefs":false,"markdown":"\n## Aims\n\nOur aims in this chapter are to learn how to:\n\n-   Crop and mask a raster according to a vector layer\n\n-   Switch from vector to raster representation, and vice versa\n\n-   Calculate a raster of distances to nearest point\n\n-   Extract raster values from locations defined by a vector layer\n\nWe will use the following R packages:\n\n-   `sf`\n\n-   `stars`\n\n-   `units`\n\n## Masking and cropping rasters\n\n### Introduction\n\n**Masking** a raster means turning pixels values outside of a an area of interest---defined using a polygonal layer---into `NA` (Figure [10.1](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:raster-masking)). **Cropping** a raster means deleting whole rows and/or columns, so that raster extent is reduced to a new (smaller) rectangular shape, also according to the extent of a vector layer. The `[` operator can be used for masking or masking and cropping (the default).\n\nFigure 10.1: Masking a raster (<http://rpubs.com/etiennebr/visualraster>)\n\n### Masking and cropping\n\nFor an example of masking and cropping, we will prepare a raster of average NDVI over the period 2000-2019, based on `MOD13A3_2000_2019.tif`. The following code section combines what we learned in Sections [6.3.2](https://geobgu.xyz/r-2021/raster-processing.html#setting-dimension-properties), [6.6.1.3](https://geobgu.xyz/r-2021/raster-processing.html#pixel-means) and [9.3](https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-reprojection):\n\n```         \nlibrary(stars) r = read_stars(\"MOD13A3_2000_2019.tif\") names(r) = \"NDVI\" r = st_warp(r, crs = 32636) r_avg = st_apply(r, 1:2, mean, na.rm = TRUE) names(r_avg) = \"NDVI\" dates = read.csv(\"MOD13A3_2000_2019_dates2.csv\") dates$date = as.Date(dates$date) r = st_set_dimensions(r, \"band\", values = dates$date, names = \"time\")\n```\n\nWe will also read a Shapefile with a polygon of Israel borders, named `israel_borders.shp`:\n\n```         \nborders = st_read(\"israel_borders.shp\")\n```\n\nFigure [10.2](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:r-avg-and-borders) shows the average NDVI raster and the borders polygon:\n\n```         \nplot(r_avg, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), reset = FALSE) plot(st_geometry(borders), add = TRUE)\n```\n\nFigure 10.2: Raster and crop/mask geometry\n\nMasking and cropping a raster, based on an `sf` layer, can be done with the `[` operator, as follows:\n\n```         \nr_avg = r_avg[borders]\n```\n\nAs we can see in Figure [10.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:r-avg-masked), all pixels that were outside of the polygon are now `NA` (this is called masking). It\\'s difficult to see, but the raster extent is also slightly reduced according to the extent of `borders` (this is called cropping):\n\n```         \nplot(r_avg, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), reset = FALSE) plot(st_geometry(borders), add = TRUE)\n```\n\nFigure 10.3: Raster after cropping and masking\n\nZooming in on a small portion of the masked raster demonstrates the masking algorithm: pixels whose *centroid* does not intersect with the polygon are converted to `NA` (Figure [10.4](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:r-avg-masked-zoom)).\n\nFigure 10.4: A small portion of the raster `r_avg`, brefore (left) after (right) cropping and masking\n\n### Masking-only\n\nIn case we need the output to keep the same extent as the input, we can mask a raster without cropping. Masking-only is done with the same operator (`[`), using the (non-default) argument `crop=FALSE`. To demonstrate the difference between masking+cropping (which we just did) and masking only, consider the following example where `r_avg` is masked *and* cropped (`r_avg1`), or just masked (`r_avg2`), according to the `\"Negev\"` administrative area. First we prepare the polygon used for masking and cropping, obtained from a Shapefile named `nafot.shp`:\n\n```         \nnafot = st_read(\"nafot.shp\") nafot = st_transform(nafot, st_crs(r)) pol = nafot[nafot$name_eng == \"Be'er Sheva\", ]\n```\n\nThen we produce the masked+cropped (`r_avg1`) and masked (`r_avg2`) rasters:\n\n```         \nr_avg1 = r_avg[pol] r_avg2 = r_avg[pol, crop = FALSE]\n```\n\nAs we can see in Figure [10.5](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:mask-vs-crop), masking transforms pixel values to `NA` (left panel) while cropping reduces raster extent by deleting whole rows and columns (right panel).\n\n```         \nplot(r_avg1, key.pos = NULL, reset = FALSE, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), axes = TRUE, main = \"mask+crop (crop=TRUE, default)\") plot(st_geometry(pol), add = TRUE) plot(st_as_sfc(st_bbox(r_avg1)), border = \"grey\", add = TRUE) plot(r_avg2, key.pos = NULL, reset = FALSE, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), axes = TRUE, main = \"mask (crop=FALSE)\") plot(st_geometry(pol), add = TRUE) plot(st_as_sfc(st_bbox(r_avg2)), border = \"grey\", add = TRUE)\n```\n\nFigure 10.5: Cropping and masking (left) vs. masking (right), raster extent is shown in grey\n\nNote that for plotting the raster extents (grey boxes in Figure [10.5](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:mask-vs-crop)), the above code section uses a combination of `st_bbox` and `st_as_sfc`. The combination returns the bounding box of a `stars` (or `sf`) layer as an `sfc` (geometry) object. For example, the following expression returns a geometry column with a single polygon, which is the bounding box of `r_avg1`:\n\n```         \nst_as_sfc(st_bbox(r_avg1)) ## Geometry set for 1 feature  ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 620563.9 ymin: 3262755 xmax: 735425.7 ymax: 3487847 ## Projected CRS: WGS 84 / UTM zone 36N ## POLYGON ((620563.9 3262755, 735425.7 3262755, 7...\n```\n\n## Vector layer → raster\n\n### 10.2.1 The `st_rasterize` function\n\nThe `st_rasterize` function converts a vector layer to a raster, given two arguments:\n\n-   `sf`---The vector layer to convert\n\n-   `template`---A raster \\\"template\\\" (if missing, it can be generated automatically)\n\nThe resulting raster retains the original values, from the `template`, in pixels that do not overlap with the vector layer (Figure [10.6](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:rasterizing-raster)). For pixels that *do* overlap with the vector layer, the value of the (first) vector layer attribute is \\\"burned\\\" into the pixels. The default meaning of the term \\\"overlap\\\" in the context of point, line, or polygon geometries, is:\n\n-   Pixels that a point *intersects* with\n\n-   Pixels chosen using [Bresenham\\'s line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n\n-   Pixels whose *centroid* intersects with the polygon\n\nThe additional parameter `options=\"ALL_TOUCHED=TRUE\"` can be passed to `st_rasterize` so that all pixels intersecting with the geometry are considered \\\"overlapping\\\" (Figure [10.6](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:rasterizing-raster)).\n\nFigure 10.6: Rasterizing points, lines and polygons to raster with `st_rasterize`, using the default algorithms (top) and `options=\"ALL_TOUCHED=TRUE\"` (bottom).\n\nBy default, the values are burned sequentially, according to the order of features. Therefore, when there are more than one vector features coinciding with the same pixel, the attribute value of the last feature \\\"wins.\\\" Alternatively, we can add up all values of coinciding geometries, using the argument `options=\"MERGE_ALG=ADD\"` (Section [10.2.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#rasterizing-point-counts)).\n\n### Rasterizing polygon attributes\n\nFor an example of rasterizing a polygon layer, let\\'s convert the `nafot` vector layer to a raster, using `r_avg` as the template. The attribute which will be \\\"burned\\\" into the raster is the `Id` of the administrative area:\n\n```         \ns = st_rasterize(nafot[, \"Id\"], r_avg)\n```\n\nThe resulting raster `s` has the same dimensions of `r_avg` but different values, as shown in Figure [10.7](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:rasterized-nafot). We can see that those areas not covered by the `nafot` layer retained their original value (average NDVI). All pixels that *were* covered by `nafot` got the `Id` attribute value.\n\n```         \nplot(nafot[, \"Id\"], pal = function(n) rep(NA, n), main = 'nafot[, \"Id\"]', border = NA, reset = FALSE, key.pos = NULL, axes = TRUE) plot(nafot[, \"Id\"], pal = function(n) hcl.colors(n, \"Spectral\"), key.pos = NULL, add = TRUE) plot(nafot[, \"Id\"], pal = function(n) rep(NA, n), main = NA, border = NA, reset = FALSE, key.pos = NULL, axes = TRUE) plot(r_avg, breaks = \"equal\", col = hcl.colors(15, \"Spectral\"), main = \"r_avg\", add = TRUE) plot(nafot[, \"Id\"], pal = function(n) rep(NA, n), main = NA, border = NA, reset = FALSE, key.pos = NULL, axes = TRUE) plot(s, breaks = \"equal\", col = hcl.colors(15, \"Spectral\"), main = 'st_rasterize(nafot[, \"Id\"], r_avg)', add = TRUE)\n```\n\nFigure 10.7: Rasterizing the `Id` of the `nafot` administrative areas layer into the average NDVI raster\n\nInstead of retaining the original values, typically we want to start with an empty template, so that the only values in the resulting raster are those coming from the vector layer. For example, we can use a copy of the `r_avg` raster, where all of the pixel values are replaced with `NA`, as the template:\n\n```         \ntemplate = r_avg template[[1]][] = NA s = st_rasterize(nafot[, \"Id\"], template)\n```\n\nThe result is shown in Figure [10.8](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:rasterized-nafot-empty-template):\n\n```         \nplot(nafot[, \"Id\"], pal = function(n) hcl.colors(n, \"Spectral\"), main = 'nafot[, \"Id\"]', key.pos = NULL, axes = TRUE) plot(nafot[, \"Id\"], pal = function(n) rep(NA, n), main = \"template\", border = NA, reset = FALSE, key.pos = NULL, axes = TRUE) plot(nafot[, \"Id\"], pal = function(n) rep(NA, n), main = NA, border = NA, reset = FALSE, key.pos = NULL, axes = TRUE) plot(s, breaks = \"equal\", col = hcl.colors(15, \"Spectral\"), main = 'st_rasterize(nafot[, \"Id\"], template)', add = TRUE)\n```\n\nFigure 10.8: Rasterizing into an empty template\n\n### Rasterizing point counts\n\nSometimes we want to *add up* attribute values from overlapping features coinciding with the same pixel, rather that take the last value. This is useful, for instance, when calculating a **point density** raster. For example, let\\'s read the `plants.shp` and `reserve.shp` Shapefiles. These Shapefiles contain a point layer of rare plants observations and a polygon with the borders of Negev Mountains Nature Reserve, the largest nature reserve in Israel, respectively:\n\n```         \nplants = st_read(\"plants.shp\") reserve = st_read(\"reserve.shp\")\n```\n\nWe will also reproject both layers to UTM, so that all pixels correspond to equal area size, which is more appropriate for density calculations:\n\n```         \nplants = st_transform(plants, 32636) reserve = st_transform(reserve, 32636)\n```\n\nFigure [10.9](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:reserve-and-plants) shows both layers---the polygonal layer `reserve` and the point layer `plants`:\n\n```         \nplot(st_geometry(reserve)) plot(st_geometry(plants), add = TRUE, col = \"red\")\n```\n\nFigure 10.9: Nature reserve and rare plants observations\n\nHow can we calculate a raster expressing the density of `plants` points across the nature reserve? First, we set up a empty template raster, where all pixels within the area of interest---the nature reserve---are given an initial value of zero. Note that we are hereby using `r_avg` as template, but, if necessary, we can prepare a new template with resolution of our choice, using `st_as_stars` (Section [9.2.1](https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#resampling)).\n\n```         \ntemplate = r_avg template[[1]][] = 0 template = template[reserve]\n```\n\nFigure [10.10](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:point-density-template) shows the template:\n\n```         \nplot(template, text_values = TRUE, col = \"lightgrey\", reset = FALSE) ## Warning in plot.stars(template, text_values = TRUE, col = \"lightgrey\", reset ## = FALSE): breaks=\"quantile\" leads to a single class; maybe try breaks=\"equal\" ## instead? plot(st_geometry(reserve), add = TRUE)\n```\n\nFigure 10.10: Template for calculating point density\n\nThen, we create a new attrubute named `count`, with a value of `1` for each plant observation:\n\n```         \nplants$count = 1\n```\n\nFinally, we rasterize the `\"count\"` attribute into the `template` raster, with an additional option `options=\"MERGE_ALG=ADD\"` (Section [10.2.1](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#the-st-rasterize-function)). The `\"MERGE_ALG=ADD\"` option acts as a *flag* instructing `st_rasterize` to add up any overlapping attributes \\\"burned\\\" into the same pixel:\n\n```         \ns = st_rasterize(plants[, \"count\"], template, options = \"MERGE_ALG=ADD\")\n```\n\nThe resulting raster values reflect the sum of the `count` attribute from all overlapping points per pixel, i.e., the number of rare plant observations per pixel (Figure [10.11](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:plants-density)):\n\n```         \nplot(s, text_values = TRUE, breaks = \"equal\", col = grey.colors(10, start = 0.6, rev = TRUE), reset = FALSE) plot(st_geometry(reserve), add = TRUE)\n```\n\nFigure 10.11: Density (observations per pixel) of rare plants in the nature reserve\n\nThe raster coloring is almost uniform, because the distribution is highly skewed. Namely, there are a lot of pixels with zero count, and few pixels with high count (try running `hist(s[[1]])` to see that). We can use a logarithmic scale to visualize the density pattern more clearly (Figure [10.12](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:plants-density-log)). Now we can see which parts of the reserve were characterized by higher occurence of rare plants.\n\n```         \nb = c(0, 10^(seq(0, 2.5, 0.5))) plot(s, breaks = b, reset = FALSE, col = hcl.colors(length(b)-1, \"Reds\", rev = TRUE)) plot(st_geometry(reserve), add = TRUE)\n```\n\nFigure 10.12: Density (observations per pixel) of rare plants in the nature reserve, with a logarithmic scale\n\n### Standardizing density units\n\nIn the observation density raster `s` (Section [10.2.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#rasterizing-point-counts)), the units of measurement are *plants per pixel*. Since a pixel happens to have an area of 0.86 km2��2 (see below), raster values are, in fact, counts per 0.86 km2��2.\n\nHow do we know that the area of a pixel is 0.86 km2��2? We can apply the `st_area` function to calculate pixel area sizes. Recall that, when applied on a vector layer, `st_area` returns a vectot of `units` values, with the corresponding areas of all geometries (Section [8.3.2.2](https://geobgu.xyz/r-2021/geometric-operations-with-vector-layers.html#area)). When `st_area` is applied on a raster, it returns a raster of area values per pixel:\n\n```         \na = st_area(s) a ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##    area [m^2]     ##  Min.   :858040   ##  1st Qu.:858040   ##  Median :858040   ##  Mean   :858040   ##  3rd Qu.:858040   ##  Max.   :858040   ## dimension(s): ##   from to  offset    delta                refsys point values x/y ## x    1 44  645574  926.305 WGS 84 / UTM zone 36N FALSE   NULL [x] ## y    1 54 3395217 -926.305 WGS 84 / UTM zone 36N FALSE   NULL [y]\n```\n\nAs usual, the area values are given in CRS units (in this case, m2�2). We can transform the `matrix` with the entire raster values (`a[[1]]`) from m2�2 to km2��2 units, using `set_units` (Section [8.3.2.2](https://geobgu.xyz/r-2021/geometric-operations-with-vector-layers.html#area)):\n\n```         \nlibrary(units) a[[1]] = set_units(a[[1]], \"km^2\") a ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##   area [km^2]    ##  Min.   :0.858   ##  1st Qu.:0.858   ##  Median :0.858   ##  Mean   :0.858   ##  3rd Qu.:0.858   ##  Max.   :0.858   ## dimension(s): ##   from to  offset    delta                refsys point values x/y ## x    1 44  645574  926.305 WGS 84 / UTM zone 36N FALSE   NULL [x] ## y    1 54 3395217 -926.305 WGS 84 / UTM zone 36N FALSE   NULL [y]\n```\n\nFinally, we can examine one of the raster values. It doesn\\'t matter which one, since all pixels have exactly the same area. For example, the following expression gives the top-left corner value from the `stars` values `matrix`:\n\n```         \na[[1]][1,1] ## 0.8580405 [km^2]\n```\n\nLet\\'s return to the density raster `s`. It is more convenient to work with counts per standard area unit, such as plants per 1 km2��2. To do that, we can divide the plants count raster `s`, by pixel area raster `a`:\n\n```         \ns = s / a names(s) = \"density\"\n```\n\nThe result is a raster with counts per unit area, in this case plant observations per km2:\n\n```         \ns ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##  density [1/km^2]   ##  Min.   :  0.0000   ##  1st Qu.:  0.0000   ##  Median :  0.0000   ##  Mean   :  0.8035   ##  3rd Qu.:  0.0000   ##  Max.   :269.2181   ##  NA's   :1191       ## dimension(s): ##   from to  offset    delta                refsys point values x/y ## x    1 44  645574  926.305 WGS 84 / UTM zone 36N FALSE   NULL [x] ## y    1 54 3395217 -926.305 WGS 84 / UTM zone 36N FALSE   NULL [y]\n```\n\nThe result is shown in Figure [10.13](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:plants-density-log-km2):\n\n```         \nb = c(0, 10^(seq(0, 2.5, 0.5))) plot(s, breaks = b, reset = FALSE, col = hcl.colors(length(b)-1, \"Reds\", rev = TRUE)) plot(st_geometry(reserve), add = TRUE)\n```\n\nFigure 10.13: Density (observations per km2��2) of rare plants in the nature reserve, with a logarithmic scale\n\nWe now move on to the opposite operation, converting a raster *to a vector layer*. As we will see, there are three variants of this conversion:\n\n-   Raster to polygons (Section [10.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-polygons))\n\n-   Raster to points (Section [10.4](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-points))\n\n-   Raster to contour (Section [10.6](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-contour))\n\n## Raster → Polygons\n\n### Raster to polygons conversion\n\nThe `st_as_sf` function makes the *raster to polygons* conversion, when using the (default) `as_points=FALSE` argument. The `st_as_sf` function ignores pixels that have a `NA` values in all layers^[35](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fn35)^. A useful option `merge=TRUE` *dissolves* all adjacent polygons that have the same raster value (in the first layer) into a single feature. The dissolve algorithm can be specified with the `connect8` parameter: 4d, which is the default (`connect8=FALSE`) or 8d (`connect8=TRUE`). The attribute table of the polygon layer contains the raster values---with a separate attribute for each layer.\n\nFor example, let\\'s take a small subset of the raster `r`:\n\n```         \nu = r[, 200:202, 100:102, 1:2]\n```\n\nWe will replace some of the pixel values with `NA`:\n\n```         \nu[[1]][2,3,] = NA u[[1]][3,2,1] = NA\n```\n\nand round the values to one digit:\n\n```         \nu = round(u, 1)\n```\n\nThe resulting small raster `u` is visualized in Figure [10.14](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:small-raster). Note that the raster has one pixel with `NA` in both layers, and another pixel with `NA` in the first layer only.\n\n```         \nplot(round(u, 2), text_values = TRUE, col = hcl.colors(4, \"Spectral\"))\n```\n\nFigure 10.14: Sample raster\n\nNow, let\\'s try using `st_as_sf` to transform the small raster `u` to a polygon layer `p`:\n\n```         \np = st_as_sf(u)\n```\n\nThe resulting polygonal layer `p` has eight polygons, even though the raster `u` had nine pixels. This is because one of the pixels had `NA` in all layers, and therefore it was not converted to a polygon:\n\n```         \np ## Simple feature collection with 8 features and 2 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 727089 ymin: 3610119 xmax: 729867.9 ymax: 3612898 ## Projected CRS: WGS 84 / UTM zone 36N ##   2000-02-01 2000-03-01                       geometry ## 1        0.7        0.7 POLYGON ((727089 3612898, 7... ## 2        0.7        0.8 POLYGON ((728015.3 3612898,... ## 3        0.6        0.7 POLYGON ((728941.6 3612898,... ## 4        0.8        0.9 POLYGON ((727089 3611972, 7... ## 5        0.7        0.8 POLYGON ((728015.3 3611972,... ## 6         NA        0.7 POLYGON ((728941.6 3611972,... ## 7        0.8        0.8 POLYGON ((727089 3611046, 7... ## 8        0.7        0.8 POLYGON ((728941.6 3611046,...\n```\n\nThe resulting layer `p`, which has eight features and two attributes, is shown in Figure [10.15](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:raster-to-polygons):\n\n```         \nplot(p)\n```\n\nFigure 10.15: Polygon layer created from a raster\n\nLet\\'s try the `merge=TRUE` option. Since merging is only affected by the first layer, it makes sense to transform each of the layers separately:\n\n```         \np1 = st_as_sf(u[,,,1], merge = TRUE) p2 = st_as_sf(u[,,,2], merge = TRUE)\n```\n\nAs a result, we have two separate polygonal layers `p1` and `p2`:\n\n```         \np1 ## Simple feature collection with 4 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 727089 ymin: 3610119 xmax: 729867.9 ymax: 3612898 ## Projected CRS: WGS 84 / UTM zone 36N ##   NDVI                       geometry ## 1  0.7 POLYGON ((727089 3612898, 7... ## 2  0.6 POLYGON ((728941.6 3612898,... ## 3  0.8 POLYGON ((727089 3611972, 7... ## 4  0.7 POLYGON ((728941.6 3611046,...\n```\n\n```         \np2 ## Simple feature collection with 6 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 727089 ymin: 3610119 xmax: 729867.9 ymax: 3612898 ## Projected CRS: WGS 84 / UTM zone 36N ##   NDVI                       geometry ## 1  0.7 POLYGON ((727089 3612898, 7... ## 2  0.8 POLYGON ((728015.3 3612898,... ## 3  0.7 POLYGON ((728941.6 3612898,... ## 4  0.9 POLYGON ((727089 3611972, 7... ## 5  0.8 POLYGON ((727089 3611046, 7... ## 6  0.8 POLYGON ((728941.6 3611046,...\n```\n\nFigure [10.16](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:raster-to-pol-merge) displays both `p1` and `p2`:\n\n```         \nplot(p1, main = paste0(colnames(p)[1], \" (\", nrow(p1), \")\")) plot(p2, main = paste0(colnames(p)[2], \" (\", nrow(p2), \")\"))\n```\n\nFigure 10.16: Polygon layer created from a raster\n\n> Do you think there will there be a difference if we use `connect8=TRUE`?\n\n### Segmentation\n\nOne example of a use case of raster to polygon conversion is the delineation of distinct inter-connected groups of pixels, sharing the same (or a similar) value. This operationis also known as **segmentation**. In it\\'s simplest form---detecting segments with exactly the same value---segmentation can be done using `st_as_sf` with `merge=TRUE`.\n\nFor example, we can derive segments of `NDVI>0.2` in the reclassified NDVI raster `l_rec_focal` from Section [9.4.3](https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#maximum-filter). First, let\\'s recreate the `l_rec_focal` raster:\n\n```         \nl = read_stars(\"landsat_04_10_2000.tif\") red = l[,,,3,drop=TRUE] nir = l[,,,4,drop=TRUE] ndvi = (nir - red) / (nir + red) names(ndvi) = \"NDVI\" l_rec = ndvi l_rec[l_rec < 0.2] = 0 l_rec[l_rec >= 0.2] = 1 get_neighbors = function(m, pos) {   i = (pos[1]-1):(pos[1]+1)   j = (pos[2]-1):(pos[2]+1)   as.vector(t(m[i, j])) } focal2 = function(r, fun, ...) {   template = r   input = t(template[[1]])   output = matrix(NA, nrow = nrow(input), ncol = ncol(input))   for(i in 2:(nrow(input) - 1)) {     for(j in 2:(ncol(input) - 1)) {       v = get_neighbors(input, c(i, j))       output[i, j] = fun(v, ...)     }   }   template[[1]] = t(output)   return(template) } l_rec_focal = focal2(l_rec, max)\n```\n\nSegments in the `l_rec_focal` raster represent distinct continuous areas with NDVI>0.2����>0.2. To detect them, we can convert the raster to polygons using `st_as_sf` with the `merge=TRUE`:\n\n```         \npol = st_as_sf(l_rec_focal, merge = TRUE)\n```\n\nThen, we filter only those segments where raster value was `1`:\n\n```         \npol = pol[pol$NDVI == 1, ]\n```\n\nThe result is a polygon layer where each feature represents a single continuous area where NDVI>0.2����>0.2:\n\n```         \npol ## Simple feature collection with 536 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 663975 ymin: 3459405 xmax: 687645 ymax: 3488145 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##    NDVI                       geometry ## 1     1 POLYGON ((675615 3488145, 6... ## 2     1 POLYGON ((676455 3488145, 6... ## 5     1 POLYGON ((681945 3488145, 6... ## 8     1 POLYGON ((684765 3488145, 6... ## 12    1 POLYGON ((687195 3488145, 6... ## 13    1 POLYGON ((686985 3488085, 6... ## 17    1 POLYGON ((686505 3488145, 6... ## 18    1 POLYGON ((665865 3488145, 6... ## 23    1 POLYGON ((685545 3488145, 6... ## 26    1 POLYGON ((686835 3487905, 6...\n```\n\nFigure [10.17](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:clump-result) shows the segments on top of the NDVI raster:\n\n```         \nplot(ndvi, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), reset = FALSE) plot(st_geometry(pol), add = TRUE)\n```\n\nFigure 10.17: Segments with NDVI\\>0.2\n\n> What is the exact number of segments in `pol`? If we ran the `st_as_sf` function on `l_rec` instead of `l_rec_focal`, do you think the number of segments would be higher or lower?\n\n## Raster → Points\n\nThe **Raster→Points** transformation is done using function `st_as_sf` with the `as_points=TRUE` option. Pixel centers---except for pixels with `NA` in all layers---become points. Just like in a conversion to polygons (Section [10.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-polygons)), the attribute table of the resulting point layer contains the raster values.\n\nFor example, here is how we can transform the small raster `u` to a point layer:\n\n```         \np = st_as_sf(u, as_points = TRUE)\n```\n\nOnce again (Section [10.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-polygons)), the resulting point layer `p` has eight points, even though the raster has nine pixels, because one of the pixels had `NA` in all layers and therefore was not converted to a point^[36](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fn36)^:\n\n```         \np ## Simple feature collection with 8 features and 2 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 727552.1 ymin: 3610583 xmax: 729404.8 ymax: 3612435 ## Projected CRS: WGS 84 / UTM zone 36N ##   2000-02-01 2000-03-01                 geometry ## 1        0.7        0.7 POINT (727552.1 3612435) ## 2        0.7        0.8 POINT (728478.4 3612435) ## 3        0.6        0.7 POINT (729404.8 3612435) ## 4        0.8        0.9 POINT (727552.1 3611509) ## 5        0.7        0.8 POINT (728478.4 3611509) ## 6         NA        0.7 POINT (729404.8 3611509) ## 7        0.8        0.8 POINT (727552.1 3610583) ## 8        0.7        0.8 POINT (729404.8 3610583)\n```\n\nThe point layer `p` is shown in Figure [10.18](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:raster-to-points):\n\n```         \nplot(p, pch = 16, cex = 3)\n```\n\nFigure 10.18: Point layer created from a raster\n\n## Distance to nearest point\n\nAnother example of a spatial operator involving a raster and a vector layer is the calculation of a raster of distances **to nearest** point. For example, we may be interested in mapping the distances to the nearest meteorological stations in Israel, to evaluate where coverage is too sparse and reliable meteorological data are missing.\n\nWe are already familiar with the `st_distance` function for calculating distances (Section [8.3.2.3](https://geobgu.xyz/r-2021/geometric-operations-with-vector-layers.html#distance)). However, `st_distance` expects two vector layers as input, not a vector layer and a raster. Therefore, to calculate a raster of distances from nearest point, we first need to convert the \\\"template\\\" raster to a point later (Section [10.4](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-points)). In this example, our template for the distances raster, hereby named `grid`, is the 926×926926×926 m2�2 raster `r_avg` (though we could use any other raster template). The `NDVI` attribute is discarded, since it is irrelevant for the distance calculation:\n\n```         \ngrid = st_as_sf(r_avg, as_points = TRUE) grid$NDVI = NULL grid ## Simple feature collection with 32858 features and 0 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 616395.6 ymin: 3262292 xmax: 770162.2 ymax: 3692097 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##                    geometry ## 1  POINT (757193.9 3691171) ## 2  POINT (758120.2 3691171) ## 3  POINT (759046.5 3691171) ## 4  POINT (753488.7 3690245) ## 5    POINT (754415 3690245) ## 6  POINT (755341.3 3690245) ## 7  POINT (756267.6 3690245) ## 8  POINT (757193.9 3690245) ## 9  POINT (758120.2 3690245) ## 10 POINT (759046.5 3690245)\n```\n\nLet\\'s also import the point layer of meteorological stations (Section [7.4](https://geobgu.xyz/r-2021/vector-layers.html#creating-point-layer-from-table)):\n\n```         \nrainfall = read.csv(\"rainfall.csv\") rainfall = st_as_sf(rainfall, coords = c(\"x_utm\", \"y_utm\"), crs = 32636)\n```\n\nNow we can use `st_distance` to calculate pairwise distances between every grid point (`grid`) and meteorological station (`rainfall`):\n\n```         \ndistance = st_distance(grid, rainfall)\n```\n\nThe result is a distance `matrix` named `distance`. Its *rows* correspond to `grid` points and its *columns* correspond to `rainfall` points. This is a very large `matrix`, due to the large number of `grid` points:\n\n```         \ndim(distance) ## [1] 32858   169\n```\n\nIn this example, we are interested in the *minimal* distance, per `grid` point, among the distances to the 169 meteorological stations. Therefore we apply the `min` function on the distance matrix *rows* (Section [4.5](https://geobgu.xyz/r-2021/tables-conditionals-and-loops.html#the-apply-function)), which refer to `grid` points. The result is a numeric vector of minimal distances, which we assign as an attribute in `grid`:\n\n```         \ngrid$distance = apply(distance, 1, min)\n```\n\nIt is also convenient to convert the distances from from m� to km��. Since `apply` returns `numeric`, thus \\\"losing\\\" the units of measurement, we first need to convert the distances to `units` and only then make the conversion:\n\n```         \ngrid$distance = set_units(grid$distance, \"m\") grid$distance = set_units(grid$distance, \"km\")\n```\n\nThe `grid` point layer now has a `distance` attribute, with the distance to nearest meteorological station, in km��:\n\n```         \ngrid ## Simple feature collection with 32858 features and 1 field ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 616395.6 ymin: 3262292 xmax: 770162.2 ymax: 3692097 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##                    geometry      distance ## 1  POINT (757193.9 3691171) 15.72760 [km] ## 2  POINT (758120.2 3691171) 16.40858 [km] ## 3  POINT (759046.5 3691171) 17.11260 [km] ## 4  POINT (753488.7 3690245) 12.55666 [km] ## 5    POINT (754415 3690245) 13.14112 [km] ## 6  POINT (755341.3 3690245) 13.76317 [km] ## 7  POINT (756267.6 3690245) 14.41792 [km] ## 8  POINT (757193.9 3690245) 15.10113 [km] ## 9  POINT (758120.2 3690245) 15.80911 [km] ## 10 POINT (759046.5 3690245) 16.53868 [km]\n```\n\nThe result is shown in Figure [10.19](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:grid-dist-points):\n\n```         \nplot(grid)\n```\n\nFigure 10.19: Distance to nearest meteorological station (point grid)\n\nTo have the results back as a raster, we can rasterize the points (Section [10.2](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#vector-layer-to-raster)). We use the same raster which we started with as template---this guarantees that every point corresponds exactly to one pixel:\n\n```         \ndistance = st_rasterize(grid[, \"distance\"], r_avg)\n```\n\nThe final raster with distances to the nearest stations is shown in Figure [10.20](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:grid-dist-raster). The locations of the meteorological stations and contour lines are shown on top of the raster, to emphasize the distance gradient:\n\n```         \nplot(distance, breaks = \"equal\", col = terrain.colors(10), reset = FALSE) plot(st_geometry(rainfall), add = TRUE, pch = 3, cex = 0.4) contour(distance, add = TRUE)\n```\n\nFigure 10.20: Distance to nearest meteorological station (raster)\n\n## Raster → Lines (contours)\n\nWe already saw how a raster can be converted to polygons (Section [10.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-polygons)) or to points (Section [10.4](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#raster-to-points)), which simply results in a layer of cell outlines or centroids, respectively. Another common transformation is to calculate **contour** lines of equal raster values.\n\nTo illustrate contour lines calculation, we will reconstruct the Haifa DEM at 90 m� resolution (Section [9.3](https://geobgu.xyz/r-2021/geometric-operations-with-rasters.html#raster-reprojection)):\n\n```         \ndem1 = read_stars(\"_book/data/srtm_43_06.tif\") dem2 = read_stars(\"_book/data/srtm_44_06.tif\") dem = st_mosaic(dem1, dem2) names(dem) = \"elevation\" dem = dem[, 5687:6287, 2348:2948] dem = st_warp(src = dem, crs = 32636, cellsize = 90)\n```\n\nRaster contours can be calculated using the `st_contour` function. The function can accept a `breaks` argument, which determines the break points where contours are generated. Another parameter named `contour_lines` determines whether contours are returned as a line layer (`TRUE`) or polygon layer (`FALSE`, the default).\n\nTo decide on `breaks` values we are interested in, it is useful to examine the range of values in the raster:\n\n```         \nrange(dem[[1]], na.rm = TRUE) ## [1] -14 541\n```\n\nAccording to the above result, we will use breaks from `-100` to `600` meters, in steps of `50` meters:\n\n```         \nb = seq(-100, 600, 50) dem_contour = st_contour(dem, breaks = b, contour_lines = TRUE)\n```\n\nThe result, `dem_contour`, is a `LINESTRING` layer with one feature per contour line:\n\n```         \ndem_contour ## Simple feature collection with 612 features and 1 field ## Geometry type: LINESTRING ## Dimension:     XY ## Bounding box:  xmin: 678607.1 ymin: 3602252 xmax: 710107.1 ymax: 3658412 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##    elevation                       geometry ## 1        150 LINESTRING (704500.1 365832... ## 2        150 LINESTRING (704680.1 365832... ## 3        200 LINESTRING (707113.3 365841... ## 4        100 LINESTRING (701332.1 365823... ## 5        350 LINESTRING (708883.5 365841... ## 6        150 LINESTRING (706102.1 365802... ## 7        100 LINESTRING (702198.3 365823... ## 8         50 LINESTRING (700342.1 365746... ## 9        200 LINESTRING (704932.1 365719... ## 10       450 LINESTRING (709117.1 365728...\n```\n\nThe contours are shown in Figure [10.21](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:contour-lines):\n\n```         \nplot(dem, breaks = b, col = terrain.colors(length(b)-1), key.pos = 4, reset = FALSE) plot(st_geometry(dem_contour), add = TRUE)\n```\n\nFigure 10.21: Contour lines\n\n## Extracting raster values\n\n### Introduction\n\nIt is often necessary to \\\"extract\\\" raster values according to overlapping vector features, such as points, lines or polygons (Figure [10.22](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:raster-extract)). For example, given an NDVI raster, we may be interested to calculate the NDVI value observed in particular *point* locations, or the average NDVI observed over an administrative area *polygon*.\n\nFigure 10.22: Extracting raster values (<http://rpubs.com/etiennebr/visualraster>)\n\nWhen extracting values to liner or polygons, it is common to summarize the values that the geometry intersects with, using a function such as `mean`. That way, the values can \\\"fit\\\" into a new attribute or attributes. Extracting to points is simpler, since each geometry corresponds to one pixel, so there is nothing to summarize.\n\nExtracting to points can be accompished with the `st_extract` function, while extracting to lines or to polygons can be accomplished with the `aggregate` function. In the next few sections, we will see examples of the most common extract scenarios:\n\n-   From **single-**band raster to **points** (Section [10.7.2](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-points-single-band))\n\n-   From **multi-**band raster to **points** (Section [10.7.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-points-multi-band))\n\n-   From **single-**band raster to **polygons** (Section [10.7.4](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-polygons-single-band))\n\n-   From **multi-**band raster to **polygons** (Section [10.7.5](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-polygons-multi-band))\n\n### Extracting to points: single-band\n\n#### NDVI in meteorological stations\n\nRaster values can be extracted *to points* using the `st_extract` function. The function accepts:\n\n-   `x`---a `stars` raster\n\n-   `pts`---a `sf` point layer\n\nand returns a new `sf` layer, with an additional attribute containing the values from `x` from the matching pixel for each point in `pts`.\n\nFor example, we can determine the average NDVI (`r_avg`) in the pixel where each meteorological station (`rainfall`) falls in, as follows:\n\n```         \nx = st_extract(r_avg, rainfall) x ## Simple feature collection with 169 features and 1 field ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 629301.4 ymin: 3270290 xmax: 761589.2 ymax: 3681163 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##         NDVI                 geometry ## 1  0.4357747 POINT (696533.1 3660837) ## 2  0.3544532 POINT (697119.1 3656748) ## 3  0.3196541 POINT (696509.3 3652434) ## 4  0.4238691 POINT (696541.7 3641332) ## 5  0.3745760 POINT (697875.3 3630156) ## 6         NA POINT (687006.2 3633330) ## 7  0.4580601 POINT (689553.7 3626282) ## 8  0.3732974 POINT (694694.5 3624388) ## 9  0.5153764 POINT (686489.5 3619716) ## 10 0.4521039 POINT (683148.4 3616846)\n```\n\nThe extracted values can be attached to the `rainfall` layer, using assignment:\n\n```         \nrainfall$NDVI = x$NDVI\n```\n\nAs a result, the `rainfall` layer now has an additional attribuite named `NDVI`:\n\n```         \nrainfall ## Simple feature collection with 169 features and 13 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 629301.4 ymin: 3270290 xmax: 761589.2 ymax: 3681163 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##       num altitude sep oct nov dec jan feb mar apr may              name ## 1  110050       30 1.2  33  90 117 135 102  61  20 6.7 Kfar Rosh Hanikra ## 2  110351       35 2.3  34  86 121 144 106  62  23 4.5              Saar ## 3  110502       20 2.7  29  89 131 158 109  62  24 3.8             Evron ## 4  111001       10 2.9  32  91 137 152 113  61  21 4.8       Kfar Masrik ## 5  111650       25 1.0  27  78 128 136 108  59  21 4.7     Kfar Hamakabi ## 6  120202        5 1.5  27  80 127 136  95  49  19 2.7        Haifa Port ## 7  120630      450 1.9  36  93 161 166 128  71  21 4.9  Haifa University ## 8  120750       30 1.6  31  91 163 170 146  76  22 4.9             Yagur ## 9  120870      210 1.1  32  93 147 147 109  61  16 4.3        Nir Etzyon ## 10 121051       20 1.8  32  85 147 142 102  56  13 4.5         En Carmel ##                    geometry      NDVI ## 1  POINT (696533.1 3660837) 0.4357747 ## 2  POINT (697119.1 3656748) 0.3544532 ## 3  POINT (696509.3 3652434) 0.3196541 ## 4  POINT (696541.7 3641332) 0.4238691 ## 5  POINT (697875.3 3630156) 0.3745760 ## 6  POINT (687006.2 3633330)        NA ## 7  POINT (689553.7 3626282) 0.4580601 ## 8  POINT (694694.5 3624388) 0.3732974 ## 9  POINT (686489.5 3619716) 0.5153764 ## 10 POINT (683148.4 3616846) 0.4521039\n```\n\nThe attribute values are shown as text labels in Figure [10.23](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:rainfall-ndvi):\n\n```         \nplot(r_avg, breaks = \"equal\", col = hcl.colors(11, \"Spectral\"), reset = FALSE) text(st_coordinates(rainfall), as.character(round(rainfall$NDVI, 2)), cex = 0.5)\n```\n\nFigure 10.23: Raster values extracted to points\n\nNow that we know the average NDVI for each meteorological station location, we can examine, for instance, the association between NDVI and rainfall in December (Figure [10.24](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:ndvi-rainfall-dec)):\n\n```         \nplot(rainfall$dec, rainfall$NDVI, xlab = \"Rainfall (mm)\", ylab = \"NDVI\")\n```\n\nFigure 10.24: Average NDVI as function of average rainfall in December\n\n> What is the *number* and *proportion* of `rainfall` points that have an `NA` value in the `NDVI` attribute? Why did those stations get `NA`?\n\n### Extracting to points: multi-band\n\nAs another example, we can extract the NDVI values for different dates from the *multi-band* raster `r`. For simplicity, let\\'s create a subset `rainfall1`, with just three meteorological stations from the `rainfall` layer:\n\n```         \nsel = c(\"Horashim\", \"Beer Sheva\", \"Yotveta\") rainfall1 = rainfall[rainfall$name %in% sel, ] rainfall1 ## Simple feature collection with 3 features and 13 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 671364.1 ymin: 3307819 xmax: 717491.2 ymax: 3648872 ## Projected CRS: WGS 84 / UTM zone 36N ##        num altitude sep oct nov dec jan feb mar apr  may       name ## 77  212168      825 3.4  37 122 202 238 190 114  38 12.2   Horashim ## 141 251690      280 0.5   9  18  38  48  40  29   9  3.6 Beer Sheva ## 168 345005       80 0.4   2   2   6   5   4   5   2  0.4    Yotveta ##                     geometry      NDVI ## 77  POINT (717491.2 3648872) 0.5041712 ## 141 POINT (671364.1 3458877) 0.1699691 ## 168 POINT (700626.3 3307819)        NA\n```\n\nNow, let\\'s extract the NDVI values from a subset with the first five bands of `r`, into `rainfall1`:\n\n```         \nrainfall1 = st_extract(r[,,,1:5], rainfall1)\n```\n\nThis time, since extraction from a multi-band raster took place, the result is a `stars` object and not an `sf` object. Moreover, this is a special type of a `stars` object, with one dimension for the vector geometries (`geometry`) and another dimension for the raster layers (`time`):\n\n```         \nrainfall1 ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##      NDVI         ##  Min.   :0.1092   ##  1st Qu.:0.1300   ##  Median :0.1564   ##  Mean   :0.2614   ##  3rd Qu.:0.4442   ##  Max.   :0.5396   ##  NA's   :1        ## dimension(s): ##          from to offset delta                refsys point ## geometry    1  3     NA    NA WGS 84 / UTM zone 36N  TRUE ## time        1  5     NA    NA                  Date    NA ##                                                                          values ## geometry POINT (717491 3648872), POINT (671364 3458877), POINT (700626 3307819) ## time                                                  2000-02-01,...,2000-06-01\n```\n\nTo work with the data, it is often more convenient to transform the `stars` object to an `sf` layer. This can be done with `st_as_sf`:\n\n```         \nrainfall1 = st_as_sf(rainfall1) rainfall1 ## Simple feature collection with 3 features and 5 fields ## Geometry type: POINT ## Dimension:     XY ## Bounding box:  xmin: 671364.1 ymin: 3307819 xmax: 717491.2 ymax: 3648872 ## Projected CRS: WGS 84 / UTM zone 36N ##   2000-02-01 2000-03-01 2000-04-01 2000-05-01 2000-06-01 ## 1     0.4314     0.4485     0.5396     0.5234     0.4772 ## 2         NA     0.1587     0.1618     0.1541     0.1489 ## 3     0.1440     0.1254     0.1251     0.1122     0.1092 ##                   geometry ## 1 POINT (717491.2 3648872) ## 2 POINT (671364.1 3458877) ## 3 POINT (700626.3 3307819)\n```\n\nIn case we are interested only in the extracted values, not the geometries, the latter can be discarded with `st_drop_geometry`:\n\n```         \nrainfall1 = st_drop_geometry(rainfall1) rainfall1 ##   2000-02-01 2000-03-01 2000-04-01 2000-05-01 2000-06-01 ## 1     0.4314     0.4485     0.5396     0.5234     0.4772 ## 2         NA     0.1587     0.1618     0.1541     0.1489 ## 3     0.1440     0.1254     0.1251     0.1122     0.1092\n```\n\nFinally, we can rely on the fact that row and column *order* matches the vector layer feature and raster layer order, respectively, to assign *names*. For example, `rainfall1` rows correspond to the selected station names, therefore we can assign the station names into `rownames`:\n\n```         \nrownames(rainfall1) = sel rainfall1 ##            2000-02-01 2000-03-01 2000-04-01 2000-05-01 2000-06-01 ## Horashim       0.4314     0.4485     0.5396     0.5234     0.4772 ## Beer Sheva         NA     0.1587     0.1618     0.1541     0.1489 ## Yotveta        0.1440     0.1254     0.1251     0.1122     0.1092\n```\n\n> Columns in `rainfall1` are already named according to image dates. Where did these names come from?\n\nThe analogous operation in **ArcGIS** is the \\\"Extract Multi Values to Points\\\" tool (Figures [10.25](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:arcgis-extract-multi1)--[10.26](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:arcgis-extract-multi2)).\n\nFigure 10.25: \\\"Extract Multi Values to Points\\\" tool in ArcGIS\n\nFigure 10.26: \\\"Extract Multi Values to Points\\\" tool in ArcGIS\n\n### Extracting to polygons: single-band\n\nExtracting raster values to polygons (or to lines) is different from extracting to points. When extracting raster values to polygons (or to lines), each vector feature is potentially associated with *more than one* pixel value (Figure [10.22](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:raster-extract)). Moreover, the number of pixels may vary between features. For example, a large polygon may cover many more pixels than a small polygon. Therefore, it is often convenient to *summarize* the raster values per polygon feauture by applying a function on them and obtaining a single number, such as the average. This is done by **aggregating** the raster based on a vector layer using function `aggregate`^[37](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fn37)^.\n\nWhen summarizing raster values per polygon feature, the `aggregate` function accepts^[38](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fn38)^:\n\n-   `x`---The `stars` raster to summarize\n\n-   `by`---An `sf` layer determining areas\n\n-   `FUN`---The function to be applied on each set of extracted pixel values from `x`\n\nFor example, we can calculate the average (`mean`) NDVI value (`r_avg`) per administrative area (`nafot`) as follows. Any additional arguments, such as `na.rm=TRUE`, are passed to the function, in this case so that `mean` excludes `NA` values:\n\n```         \nndvi_nafot = aggregate(r_avg, nafot, mean, na.rm = TRUE)\n```\n\nThe result is, again (Section [10.7.3](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#extracting-to-points-multi-band)), a special type of a `stars` object, with just one dimension for the vector geometries:\n\n```         \nndvi_nafot ## stars object with 1 dimensions and 1 attribute ## attribute(s): ##      NDVI         ##  Min.   :0.1263   ##  1st Qu.:0.3376   ##  Median :0.3845   ##  Mean   :0.3554   ##  3rd Qu.:0.4001   ##  Max.   :0.4317   ## dimension(s): ##          from to offset delta                refsys point ## geometry    1 15     NA    NA WGS 84 / UTM zone 36N FALSE ##                                                                     values ## geometry POLYGON ((739780.1 3686007,...,...,POLYGON ((674110.3 3549169,...\n```\n\nIt can be converted to the more familiar `sf` structure using `st_as_sf`:\n\n```         \nndvi_nafot = st_as_sf(ndvi_nafot)\n```\n\nNow we have a polygon layer of the administrative areas, with an `NDVI` attribute containing the average NDVI value according to the `r_avg` raster:\n\n```         \nndvi_nafot ## Simple feature collection with 15 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 620662.1 ymin: 3263494 xmax: 770624.4 ymax: 3691834 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##         NDVI                       geometry ## 1  0.4208889 POLYGON ((739780.1 3686007,... ## 2  0.3845475 POLYGON ((672273.8 3518394,... ## 3  0.3093089 POLYGON ((745560 3649860, 7... ## 4  0.3874892 POLYGON ((702283.1 3628046,... ## 5  0.4317472 POLYGON ((702725.9 3630513,... ## 6  0.4051780 POLYGON ((759304.4 3691202,... ## 7  0.3949261 POLYGON ((701391.6 3631170,... ## 8  0.4124200 POLYGON ((706537.1 3602188,... ## 9  0.3937370 POLYGON ((692687.3 3583974,... ## 10 0.3468470 POLYGON ((672841.5 3544808,...\n```\n\nThe result can be visualized as follows (Figure [10.27](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:nafot-ndvi)):\n\n```         \nplot(ndvi_nafot, pal = function(x) hcl.colors(x, \"Spectral\"), reset = FALSE, key.pos = 4) text(st_coordinates(st_centroid(ndvi_nafot)), as.character(round(ndvi_nafot$NDVI, 2)))\n```\n\nFigure 10.27: Average NDVI per \\\"Nafa\\\"\n\n### Extracting to polygons: multi-band\n\nExtracting raster values from a multi-band raster works the same way as extracting from a multi-band raster. The difference is that the resulting `stars` object has two dimensions: one for the geometries and one for the input raster bands.\n\nFor example, the following expression calculates the average `r` value for each `nafot` feature over five months starting from `2000-02-01`, based on the first *five* layers of `r`:\n\n```         \nndvi_nafot = aggregate(r[,,,1:5], nafot, mean, na.rm = TRUE) ndvi_nafot ## stars object with 2 dimensions and 1 attribute ## attribute(s): ##      NDVI         ##  Min.   :0.1083   ##  1st Qu.:0.3148   ##  Median :0.4408   ##  Mean   :0.4023   ##  3rd Qu.:0.4873   ##  Max.   :0.5906   ## dimension(s): ##          from to offset delta                refsys point ## geometry    1 15     NA    NA WGS 84 / UTM zone 36N FALSE ## time        1  5     NA    NA                  Date    NA ##                                                                     values ## geometry POLYGON ((739780.1 3686007,...,...,POLYGON ((674110.3 3549169,... ## time                                             2000-02-01,...,2000-06-01\n```\n\nWhen transformed to an `sf` layer, the values extracted from each raster layer are placed in separate attributes:\n\n```         \nndvi_nafot = st_as_sf(ndvi_nafot) ndvi_nafot ## Simple feature collection with 15 features and 5 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 620662.1 ymin: 3263494 xmax: 770624.4 ymax: 3691834 ## Projected CRS: WGS 84 / UTM zone 36N ## First 10 features: ##    2000-02-01 2000-03-01 2000-04-01 2000-05-01 2000-06-01 ## 1   0.5061847  0.5270644  0.5319248  0.4432705  0.3478298 ## 2   0.4692342  0.4604232  0.4568367  0.3757161  0.3096993 ## 3   0.5395486  0.5398781  0.4491296  0.3011687  0.2440450 ## 4   0.5616802  0.5826193  0.5475469  0.3978501  0.3062216 ## 5   0.4718739  0.4840480  0.4993016  0.4304506  0.3796581 ## 6   0.5518223  0.5851435  0.5905808  0.4905159  0.2675451 ## 7   0.4593590  0.4520991  0.4388301  0.3730517  0.3468060 ## 8   0.5061774  0.5087029  0.4809899  0.3971890  0.3509476 ## 9   0.5104205  0.4970106  0.4763348  0.3797437  0.3421975 ## 10  0.4709000  0.4675206  0.4407848  0.3536589  0.2844259 ##                          geometry ## 1  POLYGON ((739780.1 3686007,... ## 2  POLYGON ((672273.8 3518394,... ## 3  POLYGON ((745560 3649860, 7... ## 4  POLYGON ((702283.1 3628046,... ## 5  POLYGON ((702725.9 3630513,... ## 6  POLYGON ((759304.4 3691202,... ## 7  POLYGON ((701391.6 3631170,... ## 8  POLYGON ((706537.1 3602188,... ## 9  POLYGON ((692687.3 3583974,... ## 10 POLYGON ((672841.5 3544808,...\n```\n\nThe result reflects the average NDVI, for the first five months in the MODIS NDVI series, for each \\\"Nafa\\\" (Figure [10.28](https://geobgu.xyz/r-2021/combining-rasters-and-vector-layers.html#fig:nafot-ndvi-multi)):\n\n```         \nplot(ndvi_nafot, pal = function(x) hcl.colors(x, \"Spectral\"))\n```\n\nFigure 10.28: NDVI per \\\"Nafa\\\" for five months\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":"","engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":true,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["style.css"],"highlight-style":"ayu-mirage","output-file":"ch10.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.319","bibliography":["references.bib"],"linkcolor":"blue","citecolor":"red","crossref":{"fig-title":"**FIGURE**","fig-labels":"arabic","tbl-title":"**TABLE**","tbl-labels":"arabic","title-delim":"**.**"},"theme":"cosmo"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":"","engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","css":["style.css"],"highlight-style":"ayu-mirage","output-file":"ch10.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"linkcolor":"blue","citecolor":"red","crossref":{"fig-title":"**FIGURE**","fig-labels":"arabic","tbl-title":"**TABLE**","tbl-labels":"arabic","title-delim":"**.**"},"documentclass":"scrbook"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}